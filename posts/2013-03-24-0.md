---
date: 2013-03-24
layout: post
title: Calling Convention on X86 -- Using C for Example
permalink: '/2013/03-24-0.html'
categories:
- c/c++
tags:
- 基础
---


引用wikipedia上的定义：In computer science, a calling convention is a scheme for how subroutines receive parameters from their caller and how they return a result，即规定了子过程如何从它们的调用者那里取得参数并且返回结果的一种约定。它包含如下5点：

1. 参数与返回值存放的位置，可以在寄存器中，也可以在调用栈中，又或者两种都有
2. 向子过程传递参数的顺序，或者单个参数的部分。
3. 调用前设置工作和调用后清理工作，如何在调用者与被调用者之间分配。
4. 哪些寄存器可以直接被被调用者使用。
5. 哪些寄存器可以被认为是volatile和或者non-volatile，若为volatile，则无需被调用者恢复。

不同的的程序语言使用不同的调用约定，也可以运行在不同的平台之上，包括不同的CPU架构和不同的操作系统。正是如此，若整合用不同程序语言写的模块，或者调用不同程序语言所写的操作系统或者类库的API时可能会出现问题。正是由于存在这种问题，所以才有了调用约定的必要性。  

通常，一种程序语言存在多种不同的调用约定，可以由编译器所规定，也可以出于优化的情况而由程序员所指定。而不同的CPU架构也有不同的调用约定，比如X86与ARM就有不同的数量的寄存器，当然在其平台上的调用约定也是不同的。

这里我们先来了解一下X86架构的调用约定。  

X86架构拥有几种不同的调用约定。但由于其寄存器数量较少，其调用约定通常将参数存放在调用栈上，将返回值(或者其地址)存放在寄存器中。当然还有一些调用约定将参数存放入寄存器中，这类调用约定对一些参数较少同时又是leaf-routies调用将会提高不少性能(invoked frequently)。

一、调用者清理的调用约定：
----------------------
这类调用约定由调用者清理保存在栈上各个参数，典型如变参函数printf()。

**1.　cdecl**  
cdecl为C　declaration的缩写，是一种起源于C语言的调用约定。目前常用于X86架构上的多种编译器中，如VC的编译器就是默认cdecl为种调用约定。在该种调用约定中，子过程的参数被保存在栈上传递，整型返回值与内存地址通过EAX寄存器返回，浮点值则存入STO X87寄存器中返回。

在C语言的上下文(content)中，函数的参数以从右到左的顺序压入栈中。看下面个段C语言代码：

	int callee(int, int, int);
	 
	int caller(void)
	{
	    register int ret;
	 
		ret = callee(1, 2, 3);
		ret += 5;
		return ret;
	}

在X86上，上述C语言代码将成为如下汇编(AT&T syntax):

	.globl  caller
	caller:
	pushl   %ebp            ; 将上次保存栈顶压栈
	movl    %esp, %ebp      ; 保存栈顶
	pushl   $3          	; 参数压栈
	pushl   $2          	; 参数压栈
	pushl   $1          	; 参数压栈
	call    callee          ; subroutines
	addl    $12, %esp       ; 退栈
	addl    $5, %eax        ; 将subrouties返回的值加常量5
	leave
	ret

研究以上汇编，可见参数是由调用者在调用完成后清理的。这里是简单的整型返回，那如果是复杂的Struct呢，寄存器放不下了！一些编译器将复杂Struct通过内存来返回。首先调用者分配一片内存然后将其地址当作隐藏的第一个参数传入子过程中，在子过程中处理这片内存，最后将这个地址返回。当然，这只是众多处理方法中的一种而已。

二、被调用者清理的调用约定：  
-----------------------------
栈上的参数由被调用者来清理有一个前提，那就是在编译期间要明确有几个字节在栈上。因此，这类调用约定不适用于变参函数，如printf()。

**1 pascal**  
该调用约定是基于Pascal语言的调用约定，其参数压栈顺序为从左至右，在返回前由被调用者负责清理栈帧

**2 stdcall**  
该调用约定是pascal调用约定的变化版本，其参数从右至左压栈，然后由被调用者负责清理杠，返回值存入EAX寄存器中。stdcall调用约定为Win32 API的标准调用约定。

**3 fastcall**  
该调用约定没有标准化，故各编译器各有不同。其中经典的为将一个或者多个参数存放寄存器中，从而减少内存的读取。