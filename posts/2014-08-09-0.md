---
date: 2014-08-09
layout: post
title: 高效使用I/O
permalink: '/2014/08-09-0.html'
categories:
- 服务器编程
tags:
- 网络I/O
---


网络编程中，遇到最多而且必定会遇到的就是I/O了。那么，如何正确使用I/O模型，使程序能高效率运行呢?首先，我们要了解下具体有哪些I/O模型。

**I/O模型**  
基本I/O模型一般有同步和异步，阻塞和非阻塞，**基本可以分为阻塞型，非阻塞型，多路复用型和异步型4类**。

**阻塞型**  
阻塞型即最简单使用read(2)等方法。由于read(2)方法是阻塞型函数，当程序使用read(2)向输入读取数据时，如果没有任何数据读取，则read(2)函数就会阻塞，直到输入中有数据可读并读出为止。如图2中简单程序，用read(2)实现阻塞型输入操作。

	void read_input(int fd, void* data)
	{
	     char buf[BUFSIZ];
	     int n;
	 
	     n = read(fd, buf, BUFSIZ);
	     if (n < 0)      return -1;  /* failed */
	     if (n == 0) return 0;       /* EOF */
	     process(fd, buf, n);      /* success */
	 
	     return 1;
	}

图2中代码向输入读取最多BUFSIZ长度的数据，如果read(2)返回<0, 则read(2)调用失败，可能为遇到中断信号等错误，如果read(2)返回==0，则为读到文件尾，在网络通信中即对端关闭了socket连接。如果返回其他值，则说明read(2)读取输入正常，且读取n长度的数据。但是，如果输入数据大于读取的最大长度BUFSIZ时，read(2)返回BUFSIZ长度，剩下的数据等待下次read(2)进行读取。当然，这里可能出现这样的情况，输入数据正好等于BUFSIZ长度时，read(2)也返回BUFSIZ值，这时就无法判断输入数据到底还有没有剩下，只能等待下次read(2)调用时才得认证。

阻塞型模型必须循环调用read(2)以保证当有输入数据时，程序能得到这些数据。因为阻塞型模型无法知晓何时有数据可读，而且有多少数据也无从知道。在常见的网络编程中，并发存在成千上万个socket连接是很正常的现象，而阻塞型模型对每一个连接都要循环调用read(2)函数以保证每一个连接上有数据可读时能及时准备读取，这样就不得不开启N个线程（进程）进行read(2)调用，而且当大量空闲连接存在时，大量线程阻塞在read(2)上，显然这不是一个可行的方案。

可见，阻塞型模型并不是现代网络编程可以采用的网络模型。

**非阻塞型**  
非阻塞型，依旧调用read(2)等方法。但不同的是，read(2)并不会阻塞，而是立即返回。若该连接的fd被设置为O_NONBLOCK时，则read(2)表现就会略有不同。当内核有数据可读取时，则返回读取的数据，返回数据的规则和阻塞型中read(2)相同；但是当内核没有数据可读时，read(2)并不会一直阻塞直到有数据可读，而是立即返回EAGAIN或者EWOULDBLOCK。具体情况见图3中代码。

	void read_input(int fd, void*data)
	{
	     char buf[BUFSIZ];
	     int n;
	 
	     // 由于read(2)最多只能读取BUFSIZ数据，所以循环读取至无数据为止
	     for ( ; ; ) {
	          n = read(fd, buf, BUFSIZ);
	          if (n < 0) {
	               // 事先设置fd为O_NONBLOCK，所以当无数据可读时，返回error
	               if (errno == EAGAIN || errno == EWOULDBLOCK) {
	                    return 1;
	               }
	               return -1;
	          }
	          else if (n == 0) {
	               // 对端关闭连接
	               return 0;
	          }
	          else {
	               // 数据已读取，处理
	               process(fd, buf, n);
	          }
	     }
	}

图3中代码，事先对连接fd设置O_NONBLOCK（代码中无体现），所以当调用read(2)时，若内核中无数据可读时，则直接返回fail(值为-1)， 同时设置错误码为EAGAIN或者EWOULDBLOCK。同样，若返回0则表示对端可能关闭了相应的连接，现也没有数据过来了，而当返回>0时，则接收数据正常，但同样无法保证数据已读取完毕。所以，代码中采用循环读取数据，由于当内核中无数据可读时，read(2)也会立即返回，并对错误码进行置位，如此可判断数据已读取完毕。综上所述图3中代码不会对程序造成阻塞，而且也读取数据时也不会因为数据长度超过BUFSZIZ而造成读取不完整，可见，与阻塞型相比，非阻塞型解决了调用read(2)阻塞和数据可能读取不完整的问题，但是同样，在现代服务器动辄上万连接的情况下，开启同样数据线程并定时读取的方法并不可行。

**多路复用型**  
无论是阻塞型和非阻塞型，两都均不适用于现代服务器。若是出现一位管家，当fd上有数据可读时，再通知应用程序，那不是很方便。这时，多路复用就登场了。目前支持多路复用的系统调用包括select, poll, epoll, kqueue等。

说到这位管家，那就不得不说明下这管家有两种型号，分别对应在事件监视中同步的工作形态，即边沿触发和电平触发。这本来是在机械领域的两个概念，边沿触发是指只在状态变化的瞬间发出通知，而电平触发是指在状态发生变化的整个过程中都持续发出通知，具体可自行google。而在网络编程中，边沿触发和电平触发又是如何体现的呢？边沿触发，只在数据到达的瞬间产生通知，即每次数据到达只会通知一次，具体读取还是不读取，就要看应用程序了。而电平触发，只有内核缓冲区中有数据，它就会持续通知应用程序，多么敬业的一位管家啊。当然，在效率上，边沿触发还是占有绝对的优势。  
下面举下select的例子，伪代码如图4。

	int fd_socket = socket(...);     // 监听新连接socket
	bind(...);
	listen(...);
	 
	int fd_in[MAX];     // 监听已连接socket
	 
	fd_set fs;
	 
	while(1){
	  FD_ZERO(fs...);
	  // 对所有已连接socket进行监听
	  for_each(fd_in) {
	       FD_SET(fd, fs);
	  }
	  // 对接收新连接socket进行监听
	  FD_SET(fd_socket, fs);
	 
	  // 若没有任何fd可读，则阻塞
	  select(...);
	 
	  if(FD_ISSET(fd_socket...)) {
	        accept(...);
	    }
	 
	  if(FD_ISSET(fd_stdin...)) {
	        read(...);
	  }
	}

这里，select总管所有可能有数据可读的fd, 并阻塞调用直到至少有一个fd可读。当然，读者可能觉得该代码中有个小问题，就是之前描述过的read(2)数据读取不完全的情况。当然，这是个必须考虑的问题。但是select只支持电平触发，所以read(2)未读取完全，下次调用select时内核也会继续通知该fd可读，所以理论上是不会出现数据读取不完整的情况，但是由于要等到下次循环时才能读取数据，对性能有追求的情况下，依然还是可以对fd设置O_NONBLOCK，循环读取fd直到读取完毕为止。当然，在边沿触发情况下（epoll可设置），则必须使用O_NONBLOCK读取完全，否则有可能出现数据读取不完整的情况。  
当然非阻塞型非常适合现代服务器的编写，即不会造成大量线程阻塞，也不会需要成千上万的线程对每一个连接进行数据读取，这不得不说多路复用真是个好管家。

**异步型**  
若是采用异步模型，则必须使用异步接口I/O接口了。异步模型可以说是最理想的网络模型，因为CPU只是在有必要的时候参与，对CPU的利用没有一点浪费。当然，若是采用异步模型，直接采用异步接口进行编程就可以了，这里就不再赘述。