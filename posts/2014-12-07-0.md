---
date: 2014-12-07
layout: post
title: 案例研究: union-find算法(二) -- quick-find算法
permalink: '/2014/12-07-0.html'
categories:
- 算法
tags:
- union-find
---

所谓**Quick-Find算法**，顾名思义就是Find实现是Quick版本，而相对于Union，则显得不那么Quick了。当然，这是通过结论推导原因，放在这里是十分牵强的。所以，还是正常思维，如果要实现这个功能，当然，暴力算法是不可少的。而恰巧，这个暴力算法正好就是**Quick-Find算法**。

首先，我们考虑Find的实现。寻找触点p对应的分量，由于id[ ]存放着各触点对应的分量，所以简单粗暴的id[p]就是触点p对应的分量。所以，Find的实现如下：

	func (u *UFQuickFind) Find(p int) int {
	    return u.id[p]
	}

其次，再来考虑Union的实现。由于id[ ]存放着各触点对应的分量，而Union的功能就是把触点p和触点q的分量统一，即id[p]==id[q]即可，当然，原来与p(q)处于同一分量的触点也满足上式即可。所以，具体实现可参考如下：

	func (u *UFQuickFind) Union(p int, q int) {
	    pID := u.Find(p)
	    qID := u.Find(q)
	 
	    if pID == qID {
	        return
	    }
	 
	    for i := 0; i < len(u.id); i++ {
	        if u.id[i] == pID {
	            u.id[i] = qID
	        }
	    }
	 
	    u.count--
	}

分析上述Union方法的实现，简单来说就是触点p和触点q的分量如果不统一，则遍历所有触点，将原来属于触点p的分量的所有触点，全部统一成触点q的分量，如此做法即可达到触点p和触点q的分量统一，同时原先与触点p属于相同分量的其他触点依然保持处于相同分量的条件。

那么，我们来分析下Quick-Find算法是否符合我们所说的，当问题规模增大时，解决问题所花的时间是否我们依然可以接受。

首先，我们来看下Find方法。Find方法的速度显然是很快的，因为它只需要访问id[ ]数组一次。  
那么，Union方法呢。很明显，Union方法的实现并不是很理想，因为每一次调用Union方法均要遍历一次id[ ]数组。我们可以具体算一下Union方法到底访问id[ ]数组多少次。归并两个分量操作首先会调用两次Find方法，而每个Find方法都会访问id[ ]数组一次，所以Union方法最起码要访问id[ ]数组2次。然后，Union方法在需要归并的时候，必须遍历id[ ]数组一次，所以Union方法最起码要访问id[ ]数组2+N次，其中N为id[ ]数组的大小。最后，检查id[ ]数组时，如果触点的分量需要改变时，则又需要访问id[ ]数组一次，所以还要加上1 ~ N-1次数组访问（至少有一个触点是q,一个触点是p)。综上所述，归并两个分量的Union方法访问数组的次数在N+3与2N+1之间。  
单次调用Union方法其实我们并没有感觉该方法复杂度有多高（线性，id[ ]数组的访问为耗时单元），但是当我们具体处理问题时，比如我们用Quick-Find算法来解决之前说的动态连通性问题时，假设最后只得到了一个连通分量，那么根据上面的分析，我们**至少需要访问数组(N+3)(N+1) ~ N^2次**。因此，可以猜想，Quick-Find算法的复杂度是平方级别的（在最后得到少数连通分量的情况下，比如分析时的1条连通分量）。  

可见，**Quick-Find算法的复杂度是平方级别的**，即当问题规则增长为原来的2倍时，计算所需的时间则为原来的2^2(4)倍。所以，Quick-Find算法并不是十分优秀。